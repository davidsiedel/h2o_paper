@DSL DefaultGenericBehaviour;
@Behaviour PhaseFieldDamage;
@Author Jérémy Bleyer;
@Date 07 / 04 / 2020;

@Includes{
#include <TFEL/Math/Vector/tvectorIO.hxx>
}

@Gradient TVector g;
g.setEntryName("DamageGradient");
@Flux TVector q;
q.setEntryName("DualDamageGradient");

@Gradient real d;
d.setGlossaryName("Damage");
@Flux real Y;
Y.setEntryName("EnergyRelease");

@TangentOperatorBlock ∂q∕∂Δg;
@AdditionalTangentOperatorBlock ∂Y∕∂Δd;

@MaterialProperty real l₀;
l₀.setEntryName("RegularizationLength");
@MaterialProperty real Gc;
Gc.setEntryName("FractureEnergy");

@ExternalStateVariable real H;
H.setEntryName("HistoryFunction");

@AuxiliaryStateVariable real Hv;

@ProvidesTangentOperator;
@Integrator {
  // remove useless warnings, as we always compute the tangent operator
  static_cast<void>(computeTangentOperator_);
  ∂q∕∂Δg = Gc*l₀* tmatrix<N, N, real>::Id();
  const auto H_tdt = H + dH;
  Hv = H_tdt;
  ∂Y∕∂Δd = Gc/l₀+2*H_tdt;
  q = Gc*l₀*(g+Δg);
//  std::cout << "q :" << q << std::endl;
//  Y = ∂Y∕∂Δd ⋅ (d+Δd)-2*H;
  Y = (Gc/l₀+2*H_tdt) * (d+Δd) - 2*H_tdt;
//  Y = (Gc/l₀+2*H) * (d+Δd);
}

@DissipatedEnergy{
Psi_d = Gc/2/l₀*(d*d + l₀*l₀*(g|g));
}